# 変更履歴

作業用のメモです。

## 0.0.4

- `-p` オプションの追加 `-p`を使うと構文木が出力出来ます。

## 作業手順

最も重要なのは、言語の新機能の開発ですが、長い間作業しているとダレてきます。
沿うならないために、作業手順を決めていい感じで開発ループを回して行きましょう。

新しい機能に着手する場合

1. チュートリアルを書きます。
2. チュートリアル内のソースコードをdoc/tutorial/src/に書きます。
3. チュートリアルを再現する新機能を作成します。
4. `$ make ; make install`
5. `$ nmlc docs/tutorial/src/**.nml -run` で実行します。
6. 完成したらチュートリアルのコードの整合性を確かめて修正します。
7. `README.md` の変更を行います。
8. 作業メモに変更したログを記述します。
9. windowsのバイナリを生成します。
10. リリースします。

## 2014.11.03

とりあえず、パース結果の構文木を見たいので出力プログラムを書く。
なれた物なので、ただただ、書いて出来た。


	f1(a:int)= a

このプログラムが

	Prog([SExp(ELet(ECall(EVar("f1"),[ELet(EVar("a"),Ty("int"),EEmpty())]),TEmpty,EVar("a")))])

と変換されて、OCamlの

	# 22 "?"
	let f1 ~a:() = a

に変換されている事が分かる。ここまではオッケーっと

変更前がどうなってたんだってのを調べたいので、gitの戻す奴を調べるのが面倒くさい
手順だけ書き出そう

gitで戻す。出来た事にする
結果を出力するために、astの出力をバージョン上げる
パーサの該当箇所を探して直す
gen_mlを修正する
名前付きの引数の扱いを変える

## 2014.11.02

- 2進数、8進数、16進数のリテラル追加

今日はいくつ進められるかわからないのだけど、OpenGLのサンプルコードを動かして行きたい。
リテラルの追加は、字句解析を修正するだけなので簡単だ。
多値のletはパーサとジェネレータのどちらかを修正する必要がある。

jaiっていう言語を見る。かなり似ているので落ち込む？英語がぁああっ。
でも日曜だし、色々テレビ見てやる気を取り戻す。

## 2014.11.01

OpenGLのプログラムをいくつか移植してみた。
細かい修正が必要で修正した。
Cの感覚でOCamlのプログラムが書けるのが嬉しい。
キーワード引数が奇麗に書けて、let inって書かなくてよいし、配列も普通に書けて良い。

- `x,y = 1,2`で`let x,y = 1,2`としたい。
- 0x5555を使いたい
- matchの複数|対応
  value match {
    | 0 | 1 | 2 -> toggle(value)
  }


## 2014.10.31

ver 0.0.2をリリースする。とりあえず、リリースの流れを作るのが目的。
トランスレータの開発は、作業が軽いのでリリースやドキュメント周りに力を入れてみると楽しそうなのです。
作業の流れを作るとそれっぽくなるし、ユーザーとして安心感も出て行く気がするので１日から数日で1回リリースして行ってみようと思う。
ユーザーに飽きられないようにしつつ、細かなりリースを繰り返すのが良いらしいのでそうしてみる。

作業の流れは、新しい機能が追加されたら、サンプルコードを書いて、チュートリアルも変更する。
そしてこのメモに次のバージョンの新機能を記述して行く

そんな手順を書いておいてまわして行くと多分、メリハリのある開発が継続できそうなわけです。
テストがまだ入ってませんけど、いずれテストの流れも入れて行きましょう。
最も重要なのは、言語の新機能の開発です。

## 2014.10.23

NemerleとScalaを見るとどうも後置演算子がなくなっている。
C言語も++と--しか後置演算子は無いので、消してしまおう。

改行があれば;を挿入する事にする。
;があれば基本的には２項演算子は結合しなくなる。
ただし、elseやandなど特殊な演算子は結合したいので、
演算子の優先順位が3より小さければ結合する。

## 2014.10.24

オブジェクトとアクセス属性について考える。

昨日は、()は式の値を１つだけ返し、{}は名前にバインドするレコードのような物を返し、[]は値の連続を返すような物として使うと良いのではないかと考えていました。

例えば、以下の式は1を返します。

	(a=1 b=2 a+b)

また、

	{a=1 b=2+2}

はレコード{a=1 b=4}を返します。

	[1 2+2]

は[1;4]というリストを返します。

こう考えると、楽しいのですけど、パーシャルファンクションをこの中に押し込めようとすると、結構無理があります。

	{case 0 => 0 case 1 => 1 case n => fib(n-2)+fib(n-1) }

たとえば、前置のcaseがあったらそのリストみたいな感じです。
また、ブロックも{}で書きたいみたいなことがあります。
Scalaでは以下のように書きます。

	def add(a:int,b:int):int = {
		a + b
	}

この辺、値を１つだけ返す物やレコードを返すもの、リストを返すものをうまく奇麗に書きつつもっとうまくやる方法があったらいいのにと考えるわけです。


Javaのクラスは以下のようにかける。

	public class A {

		private int a = 1;
		private int b = 2;
		public A(int a, int b) {
			this.a = a;
			this.b = b;
		}

		public static void main(String[] argv) {
			A a = new A(1,2);
		}
	}

と言う具合だ。ところで、Objective-Cのメソッド定義は-から始まります。


	@interface Fib : NSObject
	-(Fib*)initWithInt:(int)n;
	-(int)fib;
	@end

	@implementation Fib {
	  int n;
	}

	-(Fib*)initWithInt:(int)m
	{
	  self = [super init];
	  if (self) {
	    n = m;
	  }
	  return self;
	}

	-(int)fib
	{
	  if (n < 2) return 1;
	  return [[[Fib alloc]initWithInt:n-2]fib] +
	         [[[Fib alloc]initWithInt:n-1]fib];
	}
	@end

また、c++のデストラクタは~書きます。

	class A {
	public:
		A(){}
		~A(){}
	}

なんか不思議です。マイナスが定義の前に付く。	
このpublicとかprivateを+や-で書いたらよくないでしょうか？

	+ class A {

		- int a = 1;
		- int b = 2;
		+ A(int a, int b) {
			this.a = a;
			this.b = b;
		}

		- static void main(String[] argv) {
			A a = new A(1,2);
		}
	}

問題があるとすると、+や-は２項演算子なので、左側の値と結合してしまう可能性があります。
でも、;があったりすればその心配もありません。改行がある場合も同様でしょう。


ところでScalaではAppを継承すると、object内でプログラムを書いて
メイン関数のように使う事が出来ます。

	object A extends App {
		private var a = 1
		println("test "+a)
	}

これもプラスとかマイナスで書けますよね。

	object A extends App {
		- var a = 1
		println("test "+a)
	}

また話が変わって、Haskellにはリストの内包表記と言う物があります。


	[x | x <- 1 .. ]

これはxは1,2,3,4,...と続くリストを表すわけです。
リスト内包表記等と言います。

### オブジェクト内包表記

レコードあるいは、オブジェクトに対する内包表記みたいな物があっても良いのではないかと思うわけです。

	{private a=1; public b=a+2; private d=5; public c=d}

言いたい事はこんな感じです。

たとえば、+がついていたら、公開するとしましょう。+が無ければ公開しません。

	{a=1; +b=a+2; d=5; +c=d}

と書いた場合は外からは２つの値しか見えないとするわけです。

	{b=3; c=5}

隠したいものにマイナスを付けるという方がよいかもしれません。

	{-a=1; b=a+2; -d=5; c=d}

ところで、private変数は実体は持ち続けますが、オブジェクト構築時に必要な変数は持ち続ける必要はないですよね。その変数には%を付けるとしてみましょう。

	{%a=1;b=a+2;%d=5;c=d}

この%aは一次変数であるので、保持されませんと。されてもされなくても構わないってのも手ですけど。なんだろ、クロージャ的に。でも、継承した場合とかにプライベートな変数といらない変数は分けて欲しいですとか。

記号は実は沢山あって、!#$%&-=^~¥|\@`+;:*,.<>/?_等があるので、左側にこれらの記号を書く事で色々な意味をもたせられるのではないでしょうか？

|があったら、それは、パーシャルファンクションの接頭詞にして@は自分として

	fib={|0=0;|1=1;|n= @(n-2) + @(n-1)}

VisualBasicのリターン値は自分の関数名に値を入れたので、

	a={@=1;p "test"}
	p a

で

	1

となるとか

	a={+1; +2}


### 各記号の役割りとかをざっくり考えてみる

!#$%&-=^~¥|\@`+;:*,.<>/


#### +

パブリックであり、1〜n個であり、正であり、足し算である。
UMLではpublic

#### -

マイナスであり、リストの項目でありUMLではprivateである。

#### \#

\# は、マクロの開始であり、#!でshebangであり、名前であり、項目の開始である。
UMLではprotectedである。プロテクテッドなのだけど、あまり知られてないというか、
protectedとして使いたいかというとイマイチ。

マクロの#は嫌だ。

#### /

/は割算であり、正規表現の開始であり、パスの区切りである。
パーシャルファンクションでも、正規表現で使いたい。
//は奇麗なコメントの始まりだ。/* */ は普通のコメント /+ +/ はDのネスト出来るより美しいコメントなイメージだ。

奇麗なイメージの強い記号で、よく使われる。

#### |

|はガードとか、パイプとか、orだからパーシャルファンクションの引数受け取りとか
Rubyのブロックの引数の受け取りとか。

#### *

0〜n個であり、ポインタ型であり、ポインタの中身を見る事であり、項目の始まりである。

#### &

& は参照とかだな。ポインタ取り出し。ポインタは危険なイメージが無くもない？

#### %

% Perlのハッシュとか、Yaccとかでは、エリアの区切りとか何かの言語のコメント
ASPのタグ<% %>

#### !

!は否定であり、shebangの実行であり、強制実行であり、参照であり、メッセージパッシングである。

	\#!/bin/sh

#### $

$ 変数でありは正規表現マッチの結果とか変数とかにマッチとかマッチの最後とか、最後の変数とかそんな意味合い。
変数のドルは飽き飽き。jQueryの$はいいかんじ。
プロンプト

#### =

= を前置っていうと、==beginとかのコメント

#### ^

^ は論理演算のnotとかなので排他的論理和とかなのでなんか排他的なかんじ。
また、正規表現の開始であり、否定である。
OCamlの文字列結合でもある。~と^をC言語で富豪的に使われてたので、
どちらかが変わる事が多い。上に付く文字であるハットって意味合いがあるからな。

#### ~

~ も排他的だったり、Dだと文字列や配列の結合とかかな。URLだと個人のフォルダとか、VIだと何も無い領域
正規表現の置き換えとか。
デストラクタなイメージもある。

#### ¥

¥はバックスラッシュと同じだったり、違ったりするので、お金の単位でもあるけど、エスケープな意味もある
DOSの¥で汚いイメージがある。

#### @

@はアノテーションであり、ドメインであり、メンバ変数であり、リストの結合である。
Rubyの@は嬉しい存在だし、Javaの@も嬉しい。


#### `

バッククオートは、マクロの特別なクアシクオートであり、システム関数の実行であり、
二項演算子にしてしまう物であり、文字列の特殊な場合である。
より先進的な機能なイメージだ。

#### ;

区切り文字であり、アセンブラのコメントの開始である。
C言語で;書きまくったためか、;書かなくて済むなら書きたくない。汚いイメージが付ている。

#### :

ラベルであり、シンボルであり、型を指定する物であり、リストの結合であり、viのコマンド入力である。

#### ,

区切り文字であり、マクロの特殊な展開である。
前置ではマクロの展開される感じかな。

#### .

終わりの文字であり、メンバであり、.textであり、拡張子の始まりである。
.netと言えばドメイン。

#### <

比較であり、継承であり、部分型であり、xmlの開始であり、テンプレートのパラメータの開始である。

#### >

比較であり、継承であり、部分型であり、xmlのタグの終了である。
コマンドプロンプト


と、記号がある。

	local {
	  a :int = 1
	  b :int = 2
	  c :int = 5
	}

ローカルな変数は公開されないし保存もされない。

	private {
	  - a :int = 1
	  - b :int = 2
	  - c :int = 5
	  + get_a() = a
	}

プライベートな変数は、publicな関数で参照するとか。

	public {
	  + a :int = 1
	  + b :int = 2
	  + c :int = 5
	}

公開される

	protected {
	  # a :int = 1
	  # b :int = 2
	  # c :int = 5
	}

フレンドとかパッケージ内のみ参照可能ってかんじ。

	static {
	  ^ a :int = 1
	  ^ b :int = 2
	  // static public
	  ^ + main(argv:Array[String]):void =
	  	println("hello world")
	}

	final {
	  ! a :int = 1
	  ! b :int = 2
	  // static public final
	  ^ + ! c:int = 3
	}

最初staticとfinalを合わせて^と$をと思ったのだけど変数名に$を使いたいので$演算子はやめた。

	pointer {
	  * a :int = 1
	  // static public final pointer
	  ^+$* c:int = 1
	}

ポインタ変数の型をここに書くのが良いのかどうかは置いておいてとりあえず書いてみた

	ref {
	  & a :int = 1
	  // static public final ref
	  ^ + $ & c:int = 1
	}

mutableな変数を&を手前に書く事で定義できたらよさそう。:の代わりに#とか考えてたのだけど。
immutableにマークがいいのかもしれないし、考えどころではある。

	virtual {
	  ? a() :int = 1
	  ? b() :int = 2
	  ^+!? c() :int = 3
	}

上書きされるメソッド等に

	override {
	  % a() :int = 10
	  % b() :int = 20
	  ^+!% c() :int = 30
	}

オーバライドしました。

	destruct {
	  ~ a() = {}
	  ~ b() = {}
	  ~ c() = {}
	}

~はデストラクタだな。

	match {
	  | 0 = 0
	  | 1 = 1
	  | n = @(n-2)+@(n-1)
	}

|でパターンマッチ

	variant type {
	  | Int(int)
	  | Add(t,t)
	  | Mul(t,t)
	}

データの定義も似た形でする。

	match {
	  | Int(i) = i
	  | Add(a,b) = @(a) + @(b)
	  | Mul(a,b) = @(a) * @(b)
	}

でパターンマッチ

	record type {
	  : a : int
	  : b : int
	  : c : int
	}

レコードの定義とかと

	match {|{a b c} = a }

パターンマッチ

	regexp {
	  /a/ = 1
	  /b/ = 2
	  /c/ = 5
	}

正規表現で文字列マッチ?

	return {
		a = 1
		b = 2
		< a
		println("kankeinai")
	}

リターン値を予約とか

	list {
		a = 1
		b = 2
		; a
		; b
	}

リスト生成

	tuple {
		a = 1
		b = 2
		, a
		, b
	}

タプル生成

	pop {
		a = 1
		b = 2
		< a
		println("kankeinai")
		> a
	}

リターンすると思ったけどポップしてしまえる。

	peek {
		a = 1
		b = 2
		< a
		println("kankeinai")
		= a
	}

リターン値をとりだす

	peek all {
		a = 1
		b = 2
		< a
		< b
		println("kankeinai")
		== a
	}

全部みる

	peek all {
		a = 1
		b = 2
		< a
		< b
		println("kankeinai")
		>> a
	}

全部取り出す

リターン値にプッシュしまくるとか、意味あるのかどうかは謎だけど、面白い。
