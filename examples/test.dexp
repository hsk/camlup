/*

./nmlc -run -to examples/test.dexp


a = (
  a = f(a; b; -c)
  a
)

b = (
  c = (
    d = 5
    d + 2
  )
  e = 1
  c + e
)

レコード

トップレベルはレコードの値宣言リストと考える。

Main module {

  add(a b) = (
    a + b
  )
  mul(a b) = (
    a * b
  )

  addt(a,b) = (
    a + b
  )

  fib(n) = (
    if (n == 0) 0 else
    if (n == 1) 1 else
    fib(n-2)+fib(n-1)
  )

  fib = (
    0 ?
      a = 0
      a
    1 ?
      b = 1
      b
    n ?
      a = fib(n-2)
      b = fib(n-1)
      a + b
  )

  printf("test%d"; fib(10))

  eval(e) =
    e match (
      Int(a)   ? k = a k
      Add(a,b) ? add(eval(a) eval(b))
      Mul(a,b) ? mul(eval(a) eval(b))
    )

  printf("1+2*3=%d" eval(Add(Int(1),Mul(Int(2),Int(3)))))

}

パターンマッチは式が含まれた関数の実行 レコードはほとんどオブジェクト

a()


*/
open Printf

printf("%s\n" "hoge")

a=1+1

printf("a=%d\n" a)

block = (
  printf("test\n")
  printf("test\n")
  printf("test\n")
  printf("test\n")
  
  a=1+1

  printf("a=%d\n" a)

)

functions(a b) = {

  printf("test %d\n" a+b)

  fib(n) =
    if (n == 0) 0
    else if (n == 1) 1
    else fib(n-2)+fib(n-1)

  printf("fib %d %d\n" a+b fib(a+b))

} functions(10 11)

pattern_match() = {

  fib(n) = {
    n match {
      0 ? 0
      1 ? -1
      n ? fib(n-2) + fib(n-1)
    }
  }

  printf("fib 21 %d\n" fib(21))
} pattern_match()


parcial_function() = {

  def fib = {
    0 ? a=1 a
    1 ? 1
    n ? fib(n-2) + fib(n-1)
  }
  
  printf("fib 10 = %d\n" fib(10))
  
  llor = {
    0,0 ? a=1 b=2 a + b
    a,b ? a + b
  }

  printf("llor %d\n" llor(1,2))
  
} parcial_function()
